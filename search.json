[{"title":"CSS 基础 - 布局无关属性","url":"/blog/2019/03/14/CSS-基础-布局无关属性/","content":"\n\n## 基本规则\n\n```CSS\n选择器{\n    属性:值;\n    属性:值;\n}\n```\n\n- 选择器\n    - 用于匹配HTML元素\n    - 有不同的匹配规则\n    - 多个选择器可以叠加\n    \n## 分类和权重\n\n### 分类\n    \n- 元素选择器 `a{}`\n- 伪元素选择器 `::before{}`\n- 类选择器 `.link{}`\n- 属性选择器 `[type = radio]{}`\n- 伪类选择器 `:hover{}`\n- ID选择器 `#id{}`\n- 组合选择器 `[type=checkbox]+label{}`\n- 否定选择器 `:not(.link){}`\n- 通用选择器 `*{}`\n\n### 权重（从高到低）\n\n 1. ID选择器 `#id{}` +100\n 2. 类 属性 伪类 +10\n 3. 元素 伪元素 +1\n 4. 其他选择器 +0\n \n - 权重计算结果不进位\n - `！important`优先级最高\n - 元素属性，优先级高\n - 相同权重，后写的生效\n\n\n\n## 解析方式和性能\n\n- 解析方式：从右往左解析，解析的过程进行验证。\n    \n    \n## 值得关注的选择器\n\n## 非布局样式\n\n###分类\n\n- 字体、字重、颜色、大小、行高\n- 背景、边框\n- 滚动、换行\n- 粗体、斜体、下划线\n- 其他\n\n### 字体\n\n- 字体族 font-family\n    - 衬线 serif \n    - 非衬线 sans-serif \n    - 等宽 monospace \n    - 手写体 cursive \n    - 花体 fantasy\n- 多字体 fallback（针对每一个字符）\n- 网络字体、自定义字体\n\n    ```CSS\n    @font-face{\n        font-family:\"名称\",\n        src: url(\"路径 or 远程地址（跨域？ cois）\")\n    }\n    ```\n    \n- iconfont\n\n**注意：**\n\n- 字体名称要加引号， 字体族不可以加引号\n\n### 行高\n\n- line-box 由最高的 inline-box 行高(line-hight)决定 \n- inline-box（设置了line-height）在line-box中垂直居中\n- 文字默认是基线（大部分字体是文字底部）对齐，可以通过设置vertical-align:\"middle\" 来实现居中对齐\n- 文字的底部和顶部 是不等于底线和顶线的\n- inline图片下边会有空隙：不是底线对齐，而是基线对齐。解决方法：设置vertical-align:\"bottom\" 底线对齐 /设置display为block，独占一行，同样就不会有间隙了\n\n### 背景\n\n- 背景颜色\n    \n    - background: 少用英文单词\n    - rgb16进制表示法： #FF0000 -> 每两位相同可简写为 #F00\n    - hsl表示法：hsl(色相0-360，饱和度0-100%，亮度0-100%, optional: 透明度0-1)\n    - background:url(路径) \n\n- 渐变色背景\n    \n    - 老写法: `background: -webkit-linear-gradient(开始位置（’left‘），颜色1，颜色2)`\n    - 新写法： `background: linear-gradient(to 开始位置（’to left‘），颜色1，颜色2)`\n    - `background: linear-gradient(角度(0deg)，颜色1，颜色2)`\n        - 0deg: 从下到上\n        - 45deg: 从左下到右上\n        - 90deg: 从左到右\n        - 180deg: 从上到下\n    - `background: linear-gradient(角度(0deg)，颜色1 出现的位置，颜色2 出现的位置， ...)`\n        - eg: `background: linear-gradient(135deg, red 0, green 10%, blue 100%)`\n    - 可以设置透明\n        - eg: `background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%,)` 这是一条斜线\n    - 设置背景大小： `background-size: 30px 30px ` 平铺满\n\n- 多背景叠加\n    \n    - 交叉网格线\n   \n    ```CSS\n    background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%,)；\n         linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%,)；\n    ```\n    \n- 背景图片和属性（雪碧图）\n    \n    - 属性：\n        \n        - background 背景色的背景图叠加不需要逗号\n        - `background: red url(./xxx.png)` 默认平铺\n        - `background-repeat: no-repeat` 不平铺 `repeat-x` x方向平铺\n        - `background-position: center center` 中间显示\n        - `background-position: 20px 30px` 距左20 距右30\n        - `background-size: 100px 50px` resize to 100px*50pz\n            - 要缩小图片\n            - 在适配移动端的时候： 1个像素对应多个屏幕实际像素，缩小图片来适应\n   \n    - 雪碧图\n        \n        - 将所有图标放在一张图上，减少HTTP请求次数\n        - 通过`background-position: -20px -30px` 和 `width: __px; height:__px` 调整要显示的图标\n\n- base64和性能优化\n    \n    - 可以用base64码，替换路径，来显示图片\n    - 一般用在小icon上\n    - 优点：减少HTTP连接数\n    - 缺点：图片体积扩大至4/3，导致CSS过大。 解码开销变大。\n\n### 边框\n\n- 属性：线型，大小，颜色\n- 边框背景图\n- 边框衔接（三角形）\n\n- 属性\n    - `border: 1px solid red` 一个像素实线红色边框\n    - 线型： solid dotted dashed\n\n- 边框背景图\n    - `border-img: url(路径) 像素 效果`\n    - 效果： 默认：拉伸 / repeat: 重复with不完整图形 / round: 重复完整图形\n    \n- 三角形衔接\n    - border边与边斜着衔接\n    - 用边框实现一个三角形， 底broder宽， 左右border透明\n\n### 滚动\n\n- 滚动行为和滚动条\n    \n    ![](https://i.imgur.com/M8UssqX.png)\n    \n### 文字折行\n\n- overflow-warp(旧：word-warp) 通用换行控制\n    - 是否保留单词\n- word-break 针对对字节文字\n    - 单词为单位 or 字母为单位\n- white-space 在空白处是否断行\n\n**Usage: 可以灵活组合**\n- overflow-warp\n    - normal(默认， 单词不换行)\n    - break-word（单词可拆，换行， 但是单词还是一个单位）\n- word-break\n    - normal(默认)\n    - break-all（单词不再当做一个单位）\n    - keep-all (所有的单词都是一个单位， 中文的句子也是一个单位) \n- white-space\n    - normal\n    - nowrap 无换行\n\n### 装饰性属性及其他\n\n- 字重（粗体）font-weight\n    - normal 默认\n    - bold\n    - bolder 更粗\n    - lighter \n    - 数字 100 - 900(只能百位数) （eg: 100）\n        - normal 一般是 400\n        - bold 一般是 700\n        - bolder 和 lighter 由父级确定\n- 斜体 font-style: itatic\n- 下划线 text-decotation\n- 指针 cursor\n\n\n### CSS Hack\n\n- 兼容 IE\n- Hack 即不合法但生效的写法\n- 主要用于区分不同浏览器\n- 缺点： 难理解 难维护 易失效\n- 替代方案：特性检测 针对性的加class\n- 写hack时，标准属性在前面，特殊属性写后边\n\n","tags":["CSS"]},{"title":"React-Navigation","url":"/blog/2019/03/05/React-Navigation/","content":"\n## 类型\n\n- createStackNavigator: 类似于普通的Navigator，屏幕上方导航栏；\n- createTabNavigator: createTabNavigator已弃用，使用createBottomTabNavigator和/或createMaterialTopTabNavigator替代；\n- createBottomTabNavigator：相当于iOS里面的TabBarController，屏幕下方的标签栏；\n- createMaterialTopTabNavigator：屏幕顶部的材料设计主题标签栏；\n- createDrawerNavigator: 抽屉效果，侧边滑出；\n- createSwitchNavigator：SwitchNavigator 的用途是一次只显示一个页面。\n\n## 两个概念\n\n- Screen navigation prop(屏幕导航属性)：通过navigation可以完成屏幕之间的调度操作，例如打开另一个屏幕；\n- Screen navigationOptions(屏幕导航选项)： 通过navigationOptions可以定制导航器显示屏幕的方式（例如：头部标题，选项卡标签等）；\n\n## 导航器支持的props\n\n```JSX\nconst SomeNav = StackNavigator/TabNavigator/DrawerNavigator({\n  // config\n});\n\n<SomeNav\n  screenProps={xxx}\n  ref={nav => { navigation = nav; }}\n  onNavigationStateChange=(prevState, newState, action)=>{\n  \t\n  }\n/>\n```\n\n- ref：可以通过ref属性获取到navigation；\n- onNavigationStateChange(prevState, newState, action)：顶级节点除了ref属性之外，还接受onNavigationStateChange(prevState, newState, action)属性，每次当导航器所管理的state发生改变时，都会回调该方法；\n    - prevState：变化之前的state；\n    - newState：新的state；\n    - 导致state变化的action；\n- screenProps：向子屏幕传递额外的数据，子屏幕可以通过this.props.screenProps获取到该数据。\n\n## Screen Navigation Prop(屏幕的navigation Prop)\n\n当导航器中的屏幕被打开时，它会收到一个navigation prop，navigation prop是整个导航环节的关键一员，接下来就详细讲解一下navigation的作用。\n\n### navigation包含以下功能：\n\n    - navigate：跳转到其他界面；\n    - state：屏幕的当前state；\n    - setParams：改变路由的params；\n    - goBack：关闭当前屏幕；\n    - dispatch：向路由发送一个action；\n    - addListener：订阅导航生命周期的更新；\n    - isFocused：true 标识屏幕获取了焦点；\n    - getParam：获取具有回退的特定参数；\n    - dangerouslyGetParent：返回父导航器；\n\n注意：一个navigation有可能没有navigate、setParams以及goBack，只有state与dispatch，所以在使用navigate时要进行判断，如果没有navigate可以使用navigation去dispatch一个新的action。如：\n\n```JSX\nconst {navigation,theme,selectedTab}=this.props;\nconst resetAction = StackActions.reset({\n    index: 0,\n    actions: [\n        NavigationActions.navigate({\n            routeName: 'HomePage',\n            params:{\n                theme:theme,\n                selectedTab:selectedTab\n            },\n        })\n    ]\n})\nnavigation.dispatch(resetAction)\n```\n\n### StackNavigator的navigation的额外功能:\n\n当且仅当当前 navigator 是 stack navigator 时，`this.props.navigation`上有一些附加功能。 这些函数是 navigate 和 goBack 的替代方法， 你可以使用任何你喜欢的方法。 这些功能是：\n\n- this.props.navigation\n    - push - 导航到堆栈中的一个新的路由\n    - pop - 返回堆栈中的上一个页面\n    - popToTop - 跳转到堆栈中最顶层的页面\n    - replace - 用新路由替换当前路由\n    - reset - 擦除导航器状态并将其替换为多个操作的结果\n    - dismiss - 关闭当前栈\n\n### 使用navigate进行界面之间的跳转\n\n- navigation.navigate({routeName, params, action, key}) 或 navigation.navigate(routeName, params, action)\n    - routeName：要跳转到的界面的路由名，也就是在导航其中配置的路由名；\n    - params：要传递给下一个界面的参数；\n    - action：如果该界面是一个navigator的话，将运行这个sub-action；\n    - key：要导航到的路由的可选标识符。 如果已存在，将后退到此路由；\n\n    \n```JSX\nexport const AppStackNavigator = createStackNavigator({\n    HomeScreen: {\n        screen: HomeScreen\n    },\n    Page1: {\n        screen: Page1\n    })\n\nclass HomeScreen extends React.Component {\n  render() {\n    const {navigate} = this.props.navigation;\n\n    return (\n      <View>\n        <Text>This is HomeScreen</Text>\n        <Button\n          onPress={() => navigate('Page1', {name: 'Devio'})}\n          title=\"Go to Page1\"\n        />\n      </View>\n     )\n   }\n}\n```\n\n### 使用state的params\n\n可以通过`this.props.state.params`来获取通过`setParams()`，或`navigation.navigate()`传递的参数。\n\n```JSX\n<Button\n    title={params.mode === 'edit' ? '保存' : '编辑'}\n    onPress={() =>\n        setParams({mode: params.mode === 'edit' ? '' : 'edit'})}\n/>\n<Button\n    title=\"Go To Page1\"\n    onPress={() => {\n        navigation.navigate('Page1',{ name: 'Devio' });\n    }}\n/>\nconst {navigation} = this.props;\nconst {state, setParams} = navigation;\nconst {params} = state;\nconst showText = params.mode === 'edit' ? '正在编辑' : '编辑完成';\n```\n\n### 使用setParams 改变route params\n\n`setParams: function setParams(params)`： 我们可以借助setParams来改变route params，比如，通过setParams来更新页面顶部的标题，返回按钮等；\n\n\n```JSX\nclass ProfileScreen extends React.Component {\n  render() {\n    const {setParams} = this.props.navigation;\n    return (\n      <Button\n        onPress={() => setParams({name: 'Lucy'})}\n        title=\"Set title name to 'Lucy'\"\n      />\n     )\n   }\n}\n```\n\n- 注意navigation.setParams改变的是当前页面的Params，如果要改变其他页面的Params可以通过NavigationActions.setParams完成.\n\n### 使用goBack返回到上一页面或指定页面\n\n- goBack: function goBack(key)：我们可以借助goBack返回到上一页或者路由栈的指定页面。\n    - 其中key表示你要返回到页面的页面标识如id-1517035332238-4，不是routeName。\n    - 可以通过指定页面的navigation.state.key来获得页面的标识。\n    - key非必传，也可传null。\n    - `navigation.state {params: {…}, key: \"id-1517035332238-4\", routeName: \"Page1\"}`\n    \n```JSX\nexport default class Page1 extends React.Component {\n    render() {\n        const {navigation} = this.props;\n        return <View style=>\n            <Text style={styles.text}>欢迎来到Page1</Text>\n            <Button\n                title=\"Go Back\"\n                onPress={() => {\n                    navigation.goBack();\n                }}\n            />\n        </View>\n    }\n}\n```\n\n### 通过dispatch发送一个action\n\n- dispatch: function dispatch(action)：给当前界面设置action，会替换原来的跳转，回退等事件。\n\n```JSX\nconst resetAction = StackActions.reset({\n\tindex: 0,\n\tactions: [\n\t    NavigationActions.navigate({\n\t        routeName: 'HomePage',\n\t        params:{\n\t            theme:theme,\n\t            selectedTab:selectedTab\n\t        },\n\t    })\n\t]\n\t})\nnavigation.dispatch(resetAction)\n```\n\n## NavigationActions\n\n- Navigate : 导航到其他的页面；\n- Back : 返回到上一个页面；\n- Set Params : 设置指定页面的Params；\n- Init : 初始化一个 state 如果 state 是 undefined；\n\n### Navigate：\n\nNavigatie action会使用Navigate action的结果来更新当前的state。\n\n方法原型：navigate({routeName, params, action, key})\n\n- routeName：字符串，必选项，在app的router里注册的导航目的地的routeName。\n- params：对象，可选项，融合进目的地route的参数。\n- actions：对象，可选项(高级)，如果screen也是一个navigator，次级action可以在子router中运行。在文档中描述的任何actions都可以作为次级action。\n- key： string or null 可选，要导航到的路由的标识符。如果已存在, 则导航回此路由。\n\n\n```JSX\nimport { NavigationActions } from 'react-navigation'\n\nconst navigateAction = NavigationActions.navigate({\n  routeName: 'Profile',\n  params: {},\n  action: NavigationActions.navigate({ routeName: 'SubProfileRoute'})\n})\nthis.props.navigation.dispatch(navigateAction)\n```\n\n### Back\n\n返回到前一个screen并且关闭当前screen.backaction creator接受一个可选的参数:\n\n方法原型：back(key)\n\n- key：String 可选，这个可以和上文中讲到的goBack的key是一个概念；\n\n\n```JSX\nimport { NavigationActions } from 'react-navigation'\nconst backAction = NavigationActions.back();\nthis.props.navigation.dispatch(backAction);\n```\n\n### SetParams\n\n通过SetParams我们可以修改指定页面的Params。\n\n- params：对象，必选参数，将会被合并到已经存在页面的Params中。\n- key：字符串，必选参数，页面的key。\n\n\n```JSX\nimport { NavigationActions } from 'react-navigation'\nconst setParamsAction = NavigationActions.setParams({\n    params: { title: 'HomePage' },\n    key: 'id-1517035332238-4',\n});\n```\n\nnavigation中有setParams为什么还要有NavigationActions.setParams?\n\n- 在上文中讲到过navigation中有可能只有state与dispatch，这个时候如果要修改页面的Params，则只能通过NavigationActions.setParams了；\n- 另外，navigation.setParams只能修改当前页面的Params，而NavigationActions.setParams可以修改所有页面的Params；\n\n## StackActions\n\n- Reset ： 重置当前 state 到一个新的state；\n- Replace ： 使用另一个路由替换指定的路由；\n- Push ： 在堆栈顶部添加一个页面，然后跳转到该页面；\n- Pop ： 跳转到上一个页面；\n- PopToTop ： 跳转到堆栈最顶层的页面，并销毁其他所有页面；\n\n### Reset：\n\nReset action删掉所有的navigation state并且使用这个actions的结果来代替。\n\n- index，数组，必选，navigation state中route数组中激活route的index。\n- actions，数组，必选项，Navigation Actions数组，将会替代navigation state。\n- key：string or null 可选， 如果设置，具有给定 key 的导航器将重置。 如果为null，则根导航器将重置。\n\n\n```JSX\nimport { NavigationActions, StackActions } from 'react-navigation'\n\nconst resetAction = StackActions.reset({\n  index: 0,\n  actions: [\n    NavigationActions.navigate({ routeName: 'Profile'})\n  ]\n})\nthis.props.navigation.dispatch(resetAction)\n```\n\n使用场景比如进入APP首页后的splash页不在使用，这时可以使用NavigationActions.reset重置它。\n\nindex参数被用来定制化当前激活的route。举个例子：使用两个routes WelcomePage和HomePage给一个基础的stack navigation设置。为了重置route到HomePage，但是在堆栈中又存放在WelcomePage之上，你可以这么做:\n\n\n```JSX\nimport { NavigationActions, StackActions } from 'react-navigation'\n\nconst resetAction = StackActions.reset({\n    index: 1,\n    actions: [\n        NavigationActions.navigate({ routeName: 'WelcomePage'}),\n        NavigationActions.navigate({ routeName: 'HomePage'})\n    ]\n});\nthis.props.navigation.dispatch(resetAction);\n```\n\n### replace\n\nReplace - 用另一个路由替换指定的路由\n\n- key - string - 被替换的路由的 key，如果未指定，最近的路由将会被替换\n- newKey - string - 用于替换路线的 Key。 如果未提供，则自动生成。\n- routeName - string - routeName用于替换路由。\n- params - object - 要传入替换路由的参数。\n- action - object - 可选的子动作。\n- immediate* - boolean - 目前没有效果, 这是 stack navigator 支持动画替换（它目前不支持）的占位符。\n\n### push\n\nPush - 在堆栈顶部添加一条路由，并导航至该路由. 与navigate的区别在于，如果有已经加载的页面，navigate方法将跳转到已经加载的页面，而不会重新创建一个新的页面。 push 总是会创建一个新的页面，所以一个页面可以被多次创建\n\n- routeName - string - routeName用于替换路由。\n- params - object - 将合并到目标路由的参数（通过this.props.navigation.state.params在目标路由获取）。\n- action - Object - 可选 - （高级）如果页面是 navigator，则是在子路由器中运行的子操作。\n\n\n```JSX\nimport { StackActions } from 'react-navigation';\n\nconst pushAction = StackActions.push({\n  routeName: 'Profile',\n  params: {\n    myUserId: 9,\n  },\n});\n\nthis.props.navigation.dispatch(pushAction);\n```\n\n### Pop\n\nThe pop 一个可以返回到堆栈中上一个路由到方法，通过设置参数 n，可以指定返回的多少层。\n\n- n - number - 返回的层数\n\n\n```JSX\nimport { StackActions } from 'react-navigation';\n\nconst popAction = StackActions.pop({\n  n: 1,\n});\n\nthis.props.navigation.dispatch(popAction);\n```\n\n### popToTop\n\npopToTop 一个可以直接跳转到堆栈最顶层，并销毁其它所有页面的方法，它在功能上与StackActions.pop({n：currentIndex})相同。\n\n\n```JSX\nimport { StackActions } from 'react-navigation';\n\nthis.props.navigation.dispatch(StackActions.popToTop());\n```","tags":["React Native"]},{"title":"React Native Layout-Flexbox","url":"/blog/2019/03/04/React-Native-Layout-Flexbox/","content":"\n# React Native Layout - Flexbox\n\n## 宽和高\n\n- 尺寸无单位\n- 在Android上，view 被解释为dp, 字体被解释为sp\n- 在IOS上， 尺寸被解释为pt\n- 确保在不同dpi显示上的显示相同\n\n## React Native中Flexbox 和 Web CSS上Flexbox不同之处\n\n- 工作方式相同\n- flexDirection: React Native中默认为 'column' Web CSS中默认为 'row'\n- alignItems: React Native中默认为 'stretch' Web CSS中默认为 'flex-start'\n- flex: Web CSS flex接受多参数， 如： flex: 2 2 10%, 但是React Native中flex只接受一个参数\n- RN不支持属性： align-content, flex-basis, order, flex-basis, flex-flow, flex-grow, flex-shrink\n\n## Flex in React Native\n\n### 父视图属性（容器属性）\n\n- flexDirection enum('row', 'column', 'row-reverse', 'column-reverse')\n- flexWrap enum('wrap', 'nowrap')\n- justifyContent enum('flex-start', 'flex-end', 'center', 'space-between','space-around')\n- alignItem enum('flex-start','flex-end', 'center', 'stretch')\n\n#### 主轴和侧轴（横轴和竖轴）\n\n# React Native Development\n\n## Layout - Flexbox\n\n### 宽和高\n\n- 尺寸无单位\n- 在Android上，view 被解释为dp, 字体被解释为sp\n- 在IOS上， 尺寸被解释为pt\n- 确保在不同dpi显示上的显示相同\n\n### React Native中Flexbox 和 Web CSS上Flexbox不同之处\n\n- 工作方式相同\n- flexDirection: React Native中默认为 'column' Web CSS中默认为 'row'\n- alignItems: React Native中默认为 'stretch' Web CSS中默认为 'flex-start'\n- flex: Web CSS flex接受多参数， 如： flex: 2 2 10%, 但是React Native中flex只接受一个参数\n- RN不支持属性： align-content, flex-basis, order, flex-basis, flex-flow, flex-grow, flex-shrink\n\n### Flex in React Native\n\n#### 父视图属性（容器属性）\n\n- flexDirection enum('row', 'column', 'row-reverse', 'column-reverse')\n- flexWrap enum('wrap', 'nowrap')\n- justifyContent enum('flex-start', 'flex-end', 'center', 'space-between','space-around')\n- alignItem enum('flex-start','flex-end', 'center', 'stretch')\n\n#### 主轴和侧轴（横轴和竖轴）\n\n ![Screen Shot 2019-03-01 at 11.01.44 A](https://i.imgur.com/SQp4z4m.png)\n \n####  flexDirection\n\n定义了父视图中的子元素延横轴或侧轴方片的排列方式\n- row: 从左向右\n- row-reverse:从右向左\n- column(default): 默认的排列方式，从上向下\n- column-reverse:从下向上\n\n**Usage:**\n\n```javascript\n<View style={ {flexDirection:'row-reverse',backgroundColor:\"darkgray\",marginTop:20}}>\n    <View style={ {width:40,height:40,backgroundColor:\"darkcyan\",margin:5}}>\n    <Text style={ {fontSize:16}}>1</Text>\n  </View>\n  <View style={ {width:40,height:40,backgroundColor:\"darkcyan\",margin:5}}>\n    <Text style={ {fontSize:16}}>2</Text>\n  </View>\n  <View style={ {width:40,height:40,backgroundColor:\"darkcyan\",margin:5}}>\n    <Text style={ {fontSize:16}}>3</Text>\n  </View>\n  <View style={ {width:40,height:40,backgroundColor:\"darkcyan\",margin:5}}>\n    <Text style={ {fontSize:16}}>4</Text>\n  </View>\n  </View>\n```\n![](https://raw.githubusercontent.com/crazycodeboy/RNStudyNotes/develop/React%20Native%E5%B8%83%E5%B1%80/React%20Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/images/flexDirection.jpg)\n\n\n#### flexWrap\n\n属性定义了子元素在父视图内是否允许多行排列，默认为nowrap。\n- nowrap(default) flex的元素只排列在一行上，可能导致溢出\n- wrap flex的元素在一行排列不下时，就进行多行排列。\n\n**Usage:**\n\n```javascript\n<View \t\t style={ {flexWrap:'wrap',flexDirection:'row',backgroundColor:\"darkgray\",marginTop:20}}>\n···\n</View>\n```\n\n![](https://raw.githubusercontent.com/crazycodeboy/RNStudyNotes/develop/React%20Native%E5%B8%83%E5%B1%80/React%20Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/images/flexWrap.jpg)\n\n#### justifyContent\n\n属性定义了浏览器如何分配顺着父容器主轴的弹性（flex）元素之间及其周围的空间，默认为flex-start。\n- flex-start(default) 从行首开始排列。每行第一个弹性元素与行首对齐，同时所有后续的弹性元素与前一个对齐。\n- flex-end 从行尾开始排列。每行最后一个弹性元素与行尾对齐，其他元素将与后一个对齐。\n- center 伸缩元素向每行中点排列。每行第一个元素到行首的距离将与每行最后一个元素到行尾的距离相同。\n- space-between 在每行上均匀分配弹性元素。相邻元素间距离相同。每行第一个元素与行首对齐，每行最后一个元素与行尾对齐。\n- space-around 在每行上均匀分配弹性元素。相邻元素间距离相同。每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。\n\n**Usage:**\n\n```javascript\n<View \t\t style={ {justifyContent:'center',flexDirection:'row',backgroundColor:\"darkgray\",marginTop:20}}>\n···\n</View>\n```\n\n![](https://raw.githubusercontent.com/crazycodeboy/RNStudyNotes/develop/React%20Native%E5%B8%83%E5%B1%80/React%20Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/images/justifyContent.jpg)\n\n#### alignItems\n\nalignItems属性以与justify-content相同的方式在侧轴方向上将当前行上的弹性元素对齐，默认为stretch。\n\n- flex-start 元素向侧轴起点对齐\n- flex-end 元素向侧轴终点对齐\n- center 元素在侧轴居中。如果元素在侧轴上的高度高于其容器，那么在两个方向上溢出距离相同。\n- stretch 弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度。\n\n\n**Usage:**\n\n\n```javascript\n<View \t\t style={ {justifyContent:'center',flexDirection:'row',backgroundColor:\"darkgray\",marginTop:20}}>\n···\n</View>\n```\n\n![](https://raw.githubusercontent.com/crazycodeboy/RNStudyNotes/develop/React%20Native%E5%B8%83%E5%B1%80/React%20Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/images/alignItems.jpg)\n\n### 子视图属性\n\n- alignSelf enum(‘auto’, ‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’)\n- flex number\n\n#### alignSelf\n\nalignSelf属性以属性定义了flex容器内被选中项目的对齐方式。注意：alignSelf 属性可重写灵活容器的 alignItems 属性。\n\n- auto(default) 元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。\n- stretch\t元素被拉伸以适应容器。\n- center\t元素位于容器的中心。\n- flex-start\t元素位于容器的开头。\n- flex-end\t元素位于容器的结尾。\n\n#### flex\n\n- flex 属性定义了一个可伸缩元素的能力，默认为0。(争夺空间)\n\n**Usage:**\n\n```javascript:\n<View style={ {flexDirection:'row',height:40, backgroundColor:\"darkgray\",marginTop:20}}>\n  <View style={ {flex:1,backgroundColor:\"darkcyan\",margin:5}}>\n    <Text style={ {fontSize:16}}>flex:1</Text>\n  </View>\n  <View style={ {flex:2,backgroundColor:\"darkcyan\",margin:5}}>\n    <Text style={ {fontSize:16}}>flex:2</Text>\n  </View>\n  <View style={ {flex:3,backgroundColor:\"darkcyan\",margin:5}}>\n    <Text style={ {fontSize:16}}>flex:3</Text>\n  </View>          \n</View>\n```\n\n![](https://raw.githubusercontent.com/crazycodeboy/RNStudyNotes/develop/React%20Native%E5%B8%83%E5%B1%80/React%20Native%E5%B8%83%E5%B1%80%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/images/flex.jpg)\n\n### 其他布局\n\n#### 视图边框\n\n- borderBottomWidth number 底部边框宽度\n- borderLeftWidth number 左边框宽度\n- borderRightWidth number 右边框宽度\n- borderTopWidth number 顶部边框宽度\n- borderWidth number 边框宽度\n- borderColor 边框颜色\n\n#### 尺寸\n\n- width number\n- height number\n\n#### 外边距\n\n- margin number 外边距\n- marginBottom number 下外边距\n- marginHorizontal number 左右外边距\n- marginLeft number 左外边距\n- marginRight number 右外边距\n- marginTop number 上外边距\n- marginVertical number 上下外边距\n\n#### 内边距\n\n- padding number 内边距\n- paddingBottom number 下内边距\n- paddingHorizontal number 左右内边距\n- paddingLeft number 做内边距\n- paddingRight number 右内边距\n- paddingTop number 上内边距\n- paddingVertical number 上下内边距\n\n#### 边缘\n\n- left number 属性规定元素的左边缘。该属性定义了定位元素左外边距边界与其包含块左边界之间的偏移。\n- right number 属性规定元素的右边缘。该属性定义了定位元素右外边距边界与其包含块右边界之间的偏移\n- top number 属性规定元素的顶部边缘。该属性定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。\n- bottom number 属性规定元素的底部边缘。该属性定义了一个定位元素的下外边距边界与其包含块下边界之间的偏移。\n\n#### 定位（position）\n\n- position enum(‘absolute’, ‘relative’)属性设置元素的定位方式，为将要定位的元素定义定位规则。\n- absolute：生成绝对定位的元素，元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n- relative：生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。\n","tags":["React Native"]},{"title":"变量类型与计算","url":"/blog/2019/02/27/变量类型与计算/","content":"# 变量类型与计算\n## 题目\n1. typeof 能够得到哪些类型\n2. === 与 ==\n3. 内置函数\n4. 存储方式分为哪些\n5. 理解JSON\n\n## 知识点\n\n### 值类型 vs 引用类型 (按存储方式类型区分)\n\n- 值类型： 只进行值传递\n- 引用类型： 指针传递\n- object, function, array 都是引用类型\n- 引用类型可以无限扩展属性\n\n### typeof 运算符\n\n1. typeof 只能区分出值类型的具体类型\n\t- typeof undefined //  undefined\n\t- typeof ‘abc’ // string\n\t- typeof 123 // number\n\t- typeof true // boolean\n2. typeof引用类型中能区分出来function\n\t- typeof {} // object\n\t- typeof [] // object\n\t- typeof null // object\n\t- typeof console.log // function\n### 强制类型转换\n\n1. 字符串拼接\n\t- 100 + ’10’ // ‘10010’\n2. == 运算符\n\t- 100 == ‘100’ // true 100 -\\> ‘100’\n\t- 0 == ‘’ // true 0-\\> false  ‘’ -\\> false\n\t- null == undefined // true null -\\> false undefined -\\> false\n3. if 语句\n\t- b = 100 \n\t- if (b)  // true\n4. 逻辑运算\n\t-  10 && 0 // 0\n\t-  “” || “abc” // “abc”\n\t\n### === vs ==\n\n1. jQuery 中推荐的写法\n\t- obj.a == null\n\t- 相当于 obj.a == null || obj.a == undefined\n2. 其他地方全用 === \n\n### JS 内置函数 - 数据封装类对象\n\n- Object\n- Array\n- Boolean\n- Number\n- String\n- Function\n- Date\n- RegExp\n- Error\n\n### JSON \n\n- JSON 就是一个JS 的对象\n\n    ```js\n    JSON.stringify({a:10, b:10})\n    JSON.parse(\"{'a':10, 'b':10}\"}\n    ```\n","tags":["Javascript"]},{"title":"VSCode Plugins","url":"/blog/2019/02/15/VSCode-Plugins/","content":"\n## Theme\n- One Dark pro\n- vscode-icons\n\n## For JavaScript\n- Prettier\n- Intent 4-to-2\n- ESLint\n- Duplicate action\n- Bracket Pair Colorizer 2\n- Babel ES6/ES7\n- ES7 React/Redux/GraphQL/React-Native snippets\n- TODO Highlight\n- Debugger for Chrome\n\n## HTML & CSS\n-  IntelliSense for CSS class names\n- Auto Rename Tag\n- Open HTML in Default Browser\n\n## Docker\n- Docker\n\n## Code Sharing\n- [Visual Studio Live Share ][1]\n\n[1]:\thttps://visualstudio.microsoft.com/services/live-share/","tags":["Environment"]},{"title":"原型和原型链","url":"/blog/2019/02/14/原型和原型链/","content":"\n## 知识点\n1. 构造函数\n    *  函数名首字母大写\n    *  函数最后会默认 return this\n2. 构造函数扩展\n    *  var a = {} 其实是 var a = new Object()的语法糖\n    *  var a = [] 其实是 var a = new Array()的语法糖\n    *  function Foo(){...} 其实是 var Foo = new Function(...)的语法糖\n    *  使用instanceof判断一个函数是否是一个变量的构造函数\n    *  判断一个变量是否为数组： 变量 instanceof Array\n3. 原型规则\n    *  所有引用类型（数组，对象，函数），都具有对象特性，即可自由扩展属性（除了“null”）\n    *  所有引用类型，都具有__proto__属性（隐式原型），属性值是一个普通的对象\n    *  所有函数，都具有prototype属性（显式原型），属性值是一个普通的对象\n    *  所有引用类型，__proto__属性值指向他的构造函数的prototype的属性值\n    *  当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去他的__proto__属性（即它的构造函数的prototype）中寻找\n    \n        ```javascript\n        var obj = {};\n        obj.a = 100;\n        var arr = [];\n        arr.a = 100;\n        function fn(){}\n        fn.a = 100\n        \n        console.log(obj.__proto__) // {}\n        console.log(arr.__proto__) // []\n        console.log(fn.__proto__) // [Function]\n        console.log(fn.prototype) // fn {}\n        console.log(obj.__proto__ === Object.prototype) // true\n        ```\n    *  对象.hasOwnProperty(属性) 判断是否是对象自身属性\n4. 原型链\n    * 代码  \n    \n        ```javascript\n        function Foo(name){\n        this.name = name\n        }\n        Foo.prototype.alertName = function(){\n            console.log(this.name)\n        }\n        \n        var f = new Foo('chris')\n        f.printName = function(){\n            console.log(this.name)\n        }\n        f.printName()\n        f.alertName()\n        f.toString() // 在f.__proto__.__proto__中寻找\n        ```\n    * 原型链 \n    \n    ![Screen Shot 2018-10-30 at 16.07.12](https://lh3.googleusercontent.com/-O83_4vaZQPU/W9kZxOgpBLI/AAAAAAAATDM/h_TBc7IPf8gMbXcXFvu0W898Mybwo_hGACHMYCw/I/Screen%252BShot%252B2018-10-30%252Bat%252B16.07.12.png)\n   * instanceof 用于判断引用类型属于哪个构造方法\n   * f instanceof Foo 的判断逻辑：\n       * f的__proto__一层一层往上，能否对应到Foo.prototype \n       * 再试着判断f instanceof Object\n       \n## 解题\n1. 如何准确判断一个变量是数组\n\n    ```javascript \n    var arr = []\n    arr instanceof Array //true\n    typeof arr // object, typeof 无法判断是否是数组\n    ```\n2. 写一个原型链继承的例子\n    \n    ```javascript\n    function Elem(id){\n        this.elem = document.getElementById(id)\n    }\n    Elem.prototype.html = function (val){\n        var elem = this.elem\n        if (val){\n            elem.innerHTML = val\n            return this //链式操作\n        }else{\n            return elem.innerHTML\n        }\n    }\n    \n    \n    Elem.prototype.on = function(type, fn){\n        var elem = this.elem\n        elem.addEventListener(type, fn)\n    \n    }\n    var div1 = new Elem('div1')\n    console.log(div1.html())\n    //链式操作\n    div1.html('<p>hello</p>').on('click',function(){\n        alert('clicked')\n    })\n    ```\n3. 描述new一个对象的过程\n    *  创建一个新对象\n    *  this指向这个对象\n    *  执行代码，对this赋值\n    *  返回this\n  \n## 原型链图片\n   ![](https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png)\n   \n## More\n   [JavaScript深入之从原型到原型链](https://github.com/mqyqingfeng/Blog/issues/2)\n\n\n    \n    \n\n\n\n    ","tags":["Javascript"]},{"title":"作用域和闭包","url":"/blog/2019/02/14/作用域和闭包/","content":"\n## 知识点\n1. 执行上下文\n\t*   范围：一段script或者一个函数\n\t*   全局：变量定义，函数声明\n\t*   函数：变量定义，函数声明，this，arguments\n\t*   函数声明 vs 函数表达式\n\t*   如果使用函数表达式，必须在使用前赋值函数，否则会默认undefined\n\t\n\t\t```javascript\n\t\t//函数声明\n\t\tfunction f(){...}\n\t\t//函数表达式\n\t\tvar f = function(){...}\n\t\t```\n2. this\n\t* this要在执行时才能确认，定义时无法确认\n\t\t```javascript\n\t\tvar a = {\n\t\t    name:'A',\n\t\t    fn:function(){\n\t\t        console.log(this.name)\n\t\t    }\n\t\t}\n\t\ta.fn() // this == a \n\t\ta.fn.call({name:'B'}) // this == {name:'B'}\n\t\tvar fn1 = a.fn  // this == window\n\t\tfn1()\n\t\tfunction fn(){\n\t\t    console.log(this)\n\t\t}\n\t\tfn() // this == window\n\t\t        \n\t\t//call apply bind\n\t\tfunction fn1(name, age){\n\t\t    console.log(name)\n\t\t    console.log(this)\n\t\t}\n\t\tfn1.call({x:100}, 'chris', 20) //this = {x:100}\n\t\tfn1.apply({x：200}，['mike',25])\n\t\t//bind必须用函数表达式\n\t\tvar f2 = function(name, age){\n\t\t    console.log(name)\n\t\t    console.log(this)\n\t\t}.bind({y：200})\n\t\tfn2('chris', 20)//this == {y：200}\n\t\t```\n3. 作用域 - 静态作用域\n\t*   var: 没有块级作用域, 只有函数和全局作用域\n\t*   let: Block Scope（after ES2015）\n4. 作用域链\n\t* 自由变量: 当前作用域没有定义的变量\n\t* 获得自由变量的值，去父级作用域寻找（函数的父级作用域是函数定义时的作用域）\n5. 闭包\n\t* 函数返回一个函数\n\t* 使用场景：\n\t\t* 函数作为返回值\n\t\t* 函数作为参数传递\n\t\t\n\t```javascript\n\tfunction F1(){\n\t    var a = 100\n\t    return function(){\n\t        console.log(a)\n\t    }\n\t}\n\tvar f1 = F1()\n\tvar a = 200 //对f1里的a没有影响\n\tf1()// output 100\n\t```\n\t\n## 解题\n\n1. 说明this集中不同的使用场景\n\t* 作为构造函数执行\n\t* 作为对象属性执行\n\t* 作为普通函数执行\n\t* call apply bind\n\n2. 创建10个a标签 点击的时候弹出对应的序号\n\n\t```javascript\n\tvar i\n\tfor(i = 0; i < 10; i++){\n\t    //必须要新建函数,否则都是10\n\t    (function(i){\n\t        var a = document.createElement('a')\n\t        a.innerHTML = i + '<br>'\n\t        a.addEventListener('click',function(e){\n\t            e.preventDefault()\n\t            alert(i)\n\t        })\n\t        document.body.appendChild(a)\n\t    })(i)\n\t}\n\t```\n3. 实际开发中的闭包的应用\n\t```javascript\n\tfunction isFirstLoad(){\n\t    var _last = []\n\t    return function(id){\n\t        if (_last.indexOf(id) >= 0){\n\t            return false\n\t        }else{\n\t            _last.push(id)\n\t            return true\n\t        }\n\t    }\n\t}\n\t    \n\tvar firstLoad = isFirstLoad()\n\tconsole.log(firstLoad(10)) //T\n\tconsole.log(firstLoad(10)) //F\n\tconsole.log(firstLoad(20)) //T\n\t```\n\n","tags":["Javascript"]},{"title":"Golang notebook","url":"/blog/2019/02/14/Golang-notebook/","content":"## 变量定义\n1. var 变量名 变量类型 //可以默认为空\n\t```go\n\tvar a int // 0\n\tvar s string // \"\"\n\tvar b,c int = 3,4\n\t//集中定义\n\tvar (\n\t    b int = 3\n\t    c int = \"def\"\n\t)\n\t```\n2. 定义的变量必须使用\n3. 可以自动推断类型\n\n\t```go\n\tvar a, b, c = 3, true, \"def\"\n\t```\n4. 第一次定义可以使用:= (不可以在函数外使用)\n\t```go\n\ta, b, c := 3, true, \"def\"\n\t```\n## 内建变量类型\n1. bool, string\n2. (u)int (长度根据系统字节), (u)int8, (u)int16,(u)int32, (u)int64, uintptr\n3. byte, rune(go中的char, 32位)\n4. float32, float64, complex64(复数，实部32位，虚部32位), complex128\n\n\t```go\n\t   c := 3+4i\n\t   cmplx.Abs(c) // 5\n\t   cmplx.Pow(math.E, 1i*math.Pi)+1 // 0, 虚部会带有一个极小值偏差\n\t   cmplx.Exp(1i*math.Pi)+1 // 0 \n\t```\n\n5. 类型转换是强制的, 没有隐式转换\n\n\t```go\n\t   a, b := 3, 4\n\t   var c int\n\t   c = int(math.Sqrt(float64(a*a+b*b)))\n\t```\n\n## 常量与枚举\n1. 常量定义 const 常量名 （类型） = 值\n\n\t```go\n\t    const filename = \"test.txt\"\n\t    const(\n\t        a = 3\n\t        b = 4\n\t    ) \n\t```\n2. 常量不要随意大写\n3. 常量数值可作为任意数值类型使用\n4. 枚举\n\n\t```go\n\tconst(\n\t    cpp = iota // 0\n\t    _\n\t    python // 2\n\t    golang // 3\n\t    javascript //4 \n\t)\n\t// b, kb, mb, gb, tb, pb\n\tconst(\n\t    b = 1<<(10*iota) //itoa可作为自增值得的种子\n\t    kb\n\t    mb\n\t    gb\n\t    tb\n\t    pb\n\t)\n\t```\n## 条件语句\n1. if 条件不需要括号 \n\t![Screen Shot 2018-12-15 at 20.27.54][image-1]\n2. if 条件里可以赋值， 赋值的变量作用域就在这个if语句里\n3. switch 可以自动break, switch 后边可以没有变量， 在case中写表达式\n\n\t```go \n\tfunc grade(score int) string {\n\t\tg := \"\"\n\t\tswitch {\n\t    \tcase score < 0 || score > 100:\n\t    \t\tpanic(fmt.Sprintf(\"Wrong score: %d\", score)) // 中断程序执行\n\t    \tcase score < 60:\n\t    \t\tg = \"F\"\n\t    \tcase score < 80:\n\t    \t\tg = \"C\"\n\t    \tcase score < 90:\n\t    \t\tg = \"B\"\n\t    \tcase score <= 100:\n\t    \t\tg = \"A\"\n\t    \treturn g\n\t}\n\t```\n\n## 循环\n1. for 的条件里不需要括号， 可以省略初始条件，结束条件， 递增表达式\n\n\t```go\n\tsum := 0\n\tfor i := 1; i <= 100; i++{\n\t    sum += i\n\t}\n\t    \n\tfunc convertToBin(n int) string {\n\t    result := \"\"\n\t    for ; n > 0; n /= 2 {\n\t        lsb := n % 2\n\t        result = strconv.Itoa(lsb) + result\n\t    }\n\t    return result \n\t}\n\tfunc printFile(filename string) {\n\t    file, err := os.Open(filename)\n\t    if err != nil {\n\t        panic(err)\n\t    }\n\t        printFileContents(file)\n\t    }\n\t        \n\tfunc printFileContents(reader io.Reader) {\n\t    scanner := bufio.NewScanner(reader)\n\t    for scanner.Scan() {\n\t\t       fmt.Println(scanner.Text())\n\t    }\n\t}\n\t```\n\n## 函数\n```go\n// 函数名（变量1 类型， 变量2 类型）（返回值类型1， 返回值类型2）{}\nfunc eval(a, b int, op string) (int, error) {\n\tswitch op {\n\tcase \"+\":\n\t\treturn a + b, nil\n\tcase \"-\":\n\t\treturn a - b, nil\n\tcase \"*\":\n\t\treturn a * b, nil\n\tcase \"/\":\n\t\tq, _ := div(a, b)\n\t\treturn q, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\n\t\t\t\"unsupported operation: %s\", op)\n\t}\n}\nfunc div(a, b int) (q, r int) {\n    return a / b, a % b\n    // 或者 不建议\n    q = a / b\n    r = a % b\n    return \n}\n    \nfunc sum(numbers ...int) int {\n\ts := 0\n\tfor i := range numbers {\n\t\ts += numbers[i]\n\t}\n\treturn s\n}\n```\n\n函数式编程\n\n```go\nfunc apply(op func(int, int) int, a, b int) int {\n\tp := reflect.ValueOf(op).Pointer()\n\topName := runtime.FuncForPC(p).Name()\n\tfmt.Printf(\"Calling function %s with args \"+\n\t\t\"(%d, %d)\\n\", opName, a, b)\n    \n\treturn op(a, b)    \n}\n```\n## 指针\n1. 指针不能运算\n2. 值传递？引用传递？ go语言只有值传递\n\t```go\n\tfunc swap(a, b *int) {\n\t\t*b, *a = *a, *b\n\t}\n\t// 另外这一种做法\n\tfunc swap(a, b int) (int, int) {\n\t\treturn b, a\n\t}\n\t```\n\n[image-1]:\thttps://lh3.googleusercontent.com/-j_DKZXUMz0w/XBWwfjeyv_I/AAAAAAAATmU/h3Vy4DTuRK8X0GyqRnjN2ZD8GHzm6a3yACHMYCw/I/Screen%2BShot%2B2018-12-15%2Bat%2B20.27.54.png","tags":["Golang"]},{"title":"Java notebook","url":"/blog/2019/02/14/Java-notebook/","content":"\n### Basic Part\n\n#### Byte, Short, Int and Long\n\n1. Width\n\n   Byte: 8 bits\n\n   Short: 16 bits\n\n   Int: 32 bits\n\n   Long: 64 bits\n\n   ```java\n   long myLongValue = 1000L; //recommend to write \"L\"\n   ```\n\n2. Easy to read\n\n   ```java\n   int myIntValue = 3_123_456;\n   ```\n\n3. Variable type transfer\n\n   Byte, Short -> Int -> Long\n\n   ```java\n   byte myByteVal = 4;\n   // Wrong\n   short MyShortVal = 20 / myByteVal;\n   // the result will transfer to int automatically \n   // Correct\n   short MyShortVal = (short) (20 / myByteVal);\n   ```\n\n------\n\n#### Float and Double\n\n1. Width\n\n   Float: 32 bits\n\n   Double: 64 bits\n\n2. Easy to read\n\n   ```java\n   double pi = 3.141_592_6;\n   ```\n\n3. Recommend to use double instead of float\n\n------\n\n#### Char and Boolean\n\n1. Char\n\n   A Char variable can be a letter or a digit or a speical character or [unicode character](https://unicode-table.com/en/). \n\n   ```java\n   // a unicode character\n   char myChar3 = '\\u00A9';\n   ```\n\n2. Boolean\n\n   ```java\n   boolean isMale = false;\n   ```\n\n3. Eight primitive type of Java\n\n   byte, short, int, long, float, double, char, boolean\n\n------\n\n#### String\n\n1. String can contain a sequence of characters. \n\n2. Use plus to append another string\n\n   ```java\n   String myStr = \"This is a string\";\n   myStr = myStr + \", and this is more.\";\n   ```\n\n3. String + Int\n\n   ```java\n   String lastString = \"10\";\n   int myInt = 50;\n   lastString = lastString + myInt;\n   System.out.println(lastString);\n   // ouput is \"1050\"\n   ```\n\n4. String is an object (not primitive type).\n\n------\n\n#### Operator\n\n1. Example of \" = + - * / % \"\n\n   ```java\n   int result = 2;\n   result += 1; //same as \"result++\" or \"result += 1\"\n   // 3\n   result = result - 1; // same as \"result--\" or \"result -= 1\" \n   // 2\n   result = result * 10; // same as \"result *= 10\"\n   // 20\n   result = result / 5; // same as \"result /= 5\"\n   // 4\n   result = result % 3; //same as \"result %= 3\"\n   // 1\n   \n   ```\n\n2. Example of \"==\" \" !=\" \">\" \"<\" \"&&\" \"||\"\n\n   ```java\n   boolean isMale = false;\n   if (isMale == true)\n       System.out.println(\"Male!\");\n   int Score = 82;\n   if (Score != 100)\n       System.out.println(\"Not 100!\");\n   if (Score > 80)\n       System.out.println(\"Good score!\");\n   if (Score < 80)\n       System.out.println(\"Bad score!\");\n   int secondScore = 90;\n   if ((secondScore > Score) && (secondScore < 100))\n       System.out.println(\"Greater than firstscore and less than 100!\");\n   if ((secondScore > Score) || (secondScore < 100))\n       System.out.println(\"Greater than firstscore or less than 100!\");\n   \n   ```\n\n3. Assignment expression will return value. Be carefule when writing conditon expression \"==\".\n\n   Example:\n\n   ```java\n   boolean isCar = false;\n   if (isCar = true)\n        System.out.println(\"It's a car\");\n   // This code will ouput \"It's a car\"!!!\n   // Because \"isCar = true\" will return true.\n   \n   ```\n\n4. =?:\n\n   Example:\n\n   ```java\n   boolean isCar = false;\n   boolean wasCar = isCar? true : false;\n   // is false\n   \n   ```\n\n5. More operators\n\n   ```\n   !       Logical complement operator;\n           inverts the value of a boolean\n   ~       Unary bitwise complement\n   <<      Signed left shift\n   >>      Signed right shift\n   >>>     Unsigned right shift\n   &       Bitwise AND\n   ^       Bitwise exclusive OR\n   |       Bitwise inclusive OR\n   \n   ```\n\n------\n\n#### Semicolon  ;\n\n------\n\n#### If then else\n\nTemplate:\n\n```java\nif( condition1 ){\n    ...\n}else if( codition2 ){\n    ...\n}else{\n    ...\n}\n\n```\n\nAttention:\n\n```java\nboolean gameover = true;\nif (gameover){\n    int score = 0;\n}\n// Can't access the variables in the if code block. \n// Those variables will be deleted automatically.\n// wrong\nint finalscore = score;\n\n```\n\n------\n\n#### Method\n\nExample:\n\n```java\npublic static int methodAdd(int val1, int val2) {\n    return (val1+val2);\n}\n\n```\n\n------\n\n#### Method Overloading\n\n------\n\n#### Switch Statement\n\n```java\nswitch(switchValue){\n    case 1:\n        ...\n        break;\n    case 2:\n        ...\n        break;\n    case 3: case 4: case 5:\n        ...\n        break;\n    default:\n        ...\n        break;       \n}\n\n```\n\n------\n\n#### For Loop Statement\n\n```java\nfor(init;termination;increment){\n    ...\n}\n\n```\n\n Example\n\n```java\nfor(i=0;i<5;i++){\n    ...\n}\n\n```\n\nTip:\n\n```java\nString.format(\"%.2f\",doubleVal);\n\n```\n\n------\n\n#### Parsing Values form a String\n\nConvert String to Int\n\n```java\nint number = Integer.parseInt(numberString);\n\n```\n\nConvert String to Double\n\n```java\ndouble number = Double.parseDouble(numberString);\n\n```\n\n------\n\n### Reading User Input\n\n```java\nScanner scanner = new Scanner(System.in);\nString name = scanner.nextline();\nint age = scanner.nextInt();\nscanner.nextInt();//for the \"enter\" after the input integer; \nscanner.close();\n\n```\n\nCheck input as int\n\n```java\nScanner scanner = new Scanner(System.in);\nboolean hasNextInt = scanner.hasNextInt();\nif(hasNextInt){\n    int age = scanner.nextInt();\n    ...\n}\n\n```\n\nTip: \n\n```java\nint max = Integer.MAX_VAULE;\nint min = Integer.MIN_VAULE;\n\n```\n\n------\n\n### OOP Part\n\n#### Class\n\n1. Features: state with fields and behaviors with methods\n2. public, private, protected\n\n```java\npublic class Account{\n    private String number;\n    private double deposit;\n    \n    public Account(){\n        this(\"12345\",2.50);//has to be the first line\n    }\n    \n    public Account(String number){\n        this(number, 2.50);\n    }\n    public Account(String number, double deposit){\n        self.number = number;\n        self.deposit = deposit;\n    }\n    \n    public double getDeposit(){\n        return deposit;\n    }\n}\n\n```\n\n------\n\n#### Inheritance\n\n```java\n//Animal.java\npublic class Animal{\n    private String name;\n    private int size;\n    public Animal(String name, int size){\n        this.name = name;\n        this.size = size;\n    }\n    \n    public void eat(){\n        ...\n    }\n}\n\n```\n\n```java\n//Dog.java\npublic class Dog extends Animal{\n    private int eyes;\n    public Dog(String name, int size, int eyes){\n        this.eyes = eyes;\n        super(name, size);\n    }\n    @Override\n    public coid eat(){\n        ...\n        // if use the eat method in father class\n        super.eat();\n    }\n}\n\n```\n\n------\n\n#### Static vs Instance method\n\nStatic Methods:\n\n- declared by using a static modifier\n- can't access instance methods and instance variables directly.\n- usually used for operations that don't require any data from an instance of class(from 'this')\n- Can't use this keyword\n- \"Main\" is a static method\n\nInstance methods\n\n- belong to an instance of class\n- to use an instance methos we have to instantiate the class first usually by using the new keyword.\n- can access instance/static methods and instance/static variables.\n\n#### Static vs Instance variables \n\nStatic variables:\n\n- decalred by using keyword static \n- static variables are also known as static member variables\n- every instance of that class shares the same variables\n- if changes are made to that variable, all other instances will see the effect of the change.\n- For example, when reading uesr input using Scanner we will declare scanner as a static variable.\n- That way static methods can access it directly.\n\nInstance variables:\n\n- known as fields or member variables\n\n------\n\n#### Compostion\n\n------\n\n#### Encapsulation\n\npublic, private\n\n------\n\n#### Polymorphism\n\nTip: random int number\n\n```java\n// return 0~1 double number\nMath.random\n// generate random number between 1 to 5.\nint randomNum = (int)(Math.random*5)+1\n\n```\n\n------\n\n#### Array\n\n```java\nint[] myIntArray = new int[10];\nmyIntArray[5] = 50;\n// or\nint[] myIntArray = {1,2,3,4,5,6,7,8,9,0};\n// get length of array\nmyIntArray.length;\n\n//copy\nint[] sortedArray = Array.copyof(myIntArray, myIntArray.length);\n\n\n```\n\n","tags":["Java"]}]